#!/usr/bin/env python3
"""
Teste G1 - Microfone Real
Testa o microfone do G1 para capturar √°udio reproduzido.
"""

import time
import sys
import os
import subprocess
from pathlib import Path

# Adiciona o diret√≥rio src ao path
sys.path.insert(0, str(Path(__file__).parent / "src"))

from unitree_sdk2py.core.channel import ChannelFactoryInitialize
from unitree_sdk2py.g1.audio.g1_audio_client import AudioClient
from unitree_sdk2py.g1.arm.g1_arm_action_client import G1ArmActionClient

class G1MicrophoneRealTest:
    """Teste real do microfone do G1."""
    
    def __init__(self):
        self.interface = "en11"
        self.audio_client = None
        self.arm_client = None
        
    def initialize_sdk(self):
        """Inicializa o SDK."""
        try:
            print("üîß Inicializando SDK...")
            ChannelFactoryInitialize(0, self.interface)
            print("‚úÖ SDK inicializado")
            
            # Inicializar clientes
            self.audio_client = AudioClient()
            self.audio_client.SetTimeout(10.0)
            self.audio_client.Init()
            print("‚úÖ AudioClient inicializado")
            
            self.arm_client = G1ArmActionClient()
            self.arm_client.SetTimeout(5.0)
            self.arm_client.Init()
            print("‚úÖ ArmActionClient inicializado")
            
            return True
        except Exception as e:
            print(f"‚ùå Erro na inicializa√ß√£o: {e}")
            return False
    
    def setup_audio(self):
        """Configura o sistema de √°udio."""
        try:
            print("üîä Configurando √°udio...")
            
            # Definir volume para 100% (m√°ximo)
            volume_result = self.audio_client.SetVolume(100)
            if volume_result == 0:
                print("‚úÖ Volume configurado para 100% (m√°ximo)")
            else:
                print(f"‚ö†Ô∏è  Erro ao configurar volume: {volume_result}")
            
            return True
        except Exception as e:
            print(f"‚ùå Erro na configura√ß√£o de √°udio: {e}")
            return False
    
    def test_microphone_detection(self):
        """Testa detec√ß√£o do microfone."""
        print("\nüé§ TESTE DETEC√á√ÉO MICROFONE")
        print("=" * 40)
        
        # Verificar se h√° microfones dispon√≠veis no sistema
        try:
            # Listar dispositivos de √°udio
            result = subprocess.run(['system_profiler', 'SPAudioDataType'], 
                                  capture_output=True, text=True, timeout=10)
            
            if result.returncode == 0:
                print("üìä Dispositivos de √°udio detectados:")
                lines = result.stdout.split('\n')
                mic_lines = [line for line in lines if 'microphone' in line.lower() or 'mic' in line.lower()]
                
                if mic_lines:
                    for line in mic_lines[:5]:  # Mostrar apenas os primeiros 5
                        print(f"  - {line.strip()}")
                else:
                    print("  - Nenhum microfone espec√≠fico encontrado")
            else:
                print("‚ö†Ô∏è  N√£o foi poss√≠vel listar dispositivos de √°udio")
                
        except Exception as e:
            print(f"‚ö†Ô∏è  Erro ao detectar microfones: {e}")
        
        # Verificar microfones via ffmpeg
        try:
            result = subprocess.run(['ffmpeg', '-f', 'avfoundation', '-list_devices', 'true', '-i', ''], 
                                  capture_output=True, text=True, timeout=10)
            
            if result.returncode == 0:
                print("\nüìä Dispositivos FFmpeg:")
                lines = result.stderr.split('\n')  # FFmpeg envia para stderr
                mic_lines = [line for line in lines if 'input' in line.lower() and ('mic' in line.lower() or 'audio' in line.lower())]
                
                for line in mic_lines[:10]:  # Mostrar apenas os primeiros 10
                    print(f"  - {line.strip()}")
            else:
                print("‚ö†Ô∏è  N√£o foi poss√≠vel listar dispositivos FFmpeg")
                
        except Exception as e:
            print(f"‚ö†Ô∏è  Erro ao detectar dispositivos FFmpeg: {e}")
        
        return True
    
    def test_audio_capture(self):
        """Testa captura de √°udio do microfone."""
        print("\nüé§ TESTE CAPTURA DE √ÅUDIO")
        print("=" * 40)
        
        # Arquivo de sa√≠da para captura
        output_file = "./audio/captured_audio.wav"
        
        print("üé§ Iniciando captura de √°udio...")
        print("üìù Gravando 5 segundos de √°udio...")
        print("üîä Reproduza algum som ou fale algo...")
        
        # Comando ffmpeg para capturar √°udio
        cmd = [
            'ffmpeg',
            '-f', 'avfoundation',  # macOS audio framework
            '-i', ':0',            # Dispositivo de entrada padr√£o (microfone)
            '-ar', '16000',        # Sample rate 16kHz
            '-ac', '1',            # Mono
            '-t', '5',             # Dura√ß√£o 5 segundos
            '-y',                  # Sobrescrever arquivo
            output_file
        ]
        
        try:
            print("üé§ Gravando... (5 segundos)")
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)
            
            if result.returncode == 0 and os.path.exists(output_file):
                size = os.path.getsize(output_file)
                print(f"‚úÖ √Åudio capturado: {output_file}")
                print(f"üìä Tamanho: {size:,} bytes")
                
                # Verificar se o arquivo tem conte√∫do
                if size > 1000:  # Mais de 1KB
                    print("‚úÖ Arquivo de √°udio v√°lido")
                    return output_file
                else:
                    print("‚ö†Ô∏è  Arquivo muito pequeno - poss√≠vel sil√™ncio")
                    return None
            else:
                print(f"‚ùå Erro na captura: {result.stderr}")
                return None
                
        except Exception as e:
            print(f"‚ùå Erro ao capturar √°udio: {e}")
            return None
    
    def test_g1_audio_playback_with_capture(self):
        """Testa reprodu√ß√£o de √°udio no G1 com captura simult√¢nea."""
        print("\nüé≠ TESTE G1 + CAPTURA SIMULT√ÇNEA")
        print("=" * 50)
        
        # 1. Preparar √°udio WAV
        input_mp3 = "./audio/effects/evil-laugh-89423.mp3"
        output_wav = "./audio/effects/evil-laugh-89423.wav"
        
        if not os.path.exists(output_wav):
            print("üîÑ Convertendo MP3 para WAV...")
            cmd = [
                'ffmpeg',
                '-i', input_mp3,
                '-ar', '16000',
                '-ac', '1',
                '-f', 'wav',
                '-y',
                output_wav
            ]
            subprocess.run(cmd, capture_output=True)
        
        # 2. Ler WAV
        try:
            sys.path.insert(0, str(Path(__file__).parent / "unitree_sdk2_python/example/g1/audio"))
            from wav import read_wav as sdk_read_wav
            
            pcm_list, sample_rate, num_channels, is_ok = sdk_read_wav(output_wav)
            if not is_ok:
                print("‚ùå Erro ao ler WAV")
                return False
                
        except Exception as e:
            print(f"‚ùå Erro ao ler WAV: {e}")
            return False
        
        # 3. Iniciar captura em background
        capture_file = "./audio/g1_audio_captured.wav"
        capture_cmd = [
            'ffmpeg',
            '-f', 'avfoundation',
            '-i', ':0',
            '-ar', '16000',
            '-ac', '1',
            '-t', '10',  # Capturar 10 segundos
            '-y',
            capture_file
        ]
        
        print("üé§ Iniciando captura em background...")
        capture_process = subprocess.Popen(capture_cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        
        # 4. Aguardar um pouco para a captura iniciar
        time.sleep(1)
        
        # 5. Reproduzir √°udio no G1
        print("üéµ Reproduzindo √°udio no G1...")
        self.audio_client.LedControl(255, 0, 255)  # Magenta para teste
        
        try:
            from wav import play_pcm_stream as sdk_play_pcm_stream
            sdk_play_pcm_stream(self.audio_client, pcm_list, "test_capture", chunk_size=96000, sleep_time=0.1, verbose=False)
        except Exception as e:
            print(f"‚ùå Erro na reprodu√ß√£o: {e}")
        
        # 6. Aguardar captura terminar
        print("‚è≥ Aguardando captura terminar...")
        capture_process.wait()
        
        # 7. Verificar arquivo capturado
        if os.path.exists(capture_file):
            size = os.path.getsize(capture_file)
            print(f"‚úÖ √Åudio capturado: {capture_file}")
            print(f"üìä Tamanho: {size:,} bytes")
            
            if size > 10000:  # Mais de 10KB
                print("‚úÖ Captura bem-sucedida - poss√≠vel √°udio detectado")
                return True
            else:
                print("‚ö†Ô∏è  Captura muito pequena - poss√≠vel sil√™ncio")
                return False
        else:
            print("‚ùå Arquivo de captura n√£o encontrado")
            return False
    
    def test_microphone_directionality(self):
        """Testa se o microfone √© direcional."""
        print("\nüé§ TESTE DIRECIONALIDADE")
        print("=" * 40)
        
        print("üé§ Teste de direcionalidade:")
        print("1. Fale diretamente na frente do rob√¥")
        print("2. Fale ao lado do rob√¥")
        print("3. Fale atr√°s do rob√¥")
        print("4. Compare os volumes")
        
        # Capturar √°udio de diferentes posi√ß√µes
        positions = [
            ("frente", "Fale diretamente na frente do rob√¥"),
            ("lado", "Fale ao lado do rob√¥"),
            ("atras", "Fale atr√°s do rob√¥")
        ]
        
        for pos, instruction in positions:
            print(f"\nüé§ Posi√ß√£o: {pos}")
            print(f"üìù {instruction}")
            
            input("Pressione ENTER quando estiver pronto...")
            
            # Capturar 3 segundos
            output_file = f"./audio/mic_test_{pos}.wav"
            cmd = [
                'ffmpeg',
                '-f', 'avfoundation',
                '-i', ':0',
                '-ar', '16000',
                '-ac', '1',
                '-t', '3',
                '-y',
                output_file
            ]
            
            try:
                print("üé§ Gravando... (3 segundos)")
                result = subprocess.run(cmd, capture_output=True, text=True, timeout=5)
                
                if result.returncode == 0 and os.path.exists(output_file):
                    size = os.path.getsize(output_file)
                    print(f"‚úÖ {pos}: {size:,} bytes")
                else:
                    print(f"‚ùå {pos}: Falha na captura")
                    
            except Exception as e:
                print(f"‚ùå {pos}: Erro - {e}")
        
        print("\nüìä Compare os tamanhos dos arquivos para verificar direcionalidade")
        return True
    
    def run_test(self):
        """Executa todos os testes."""
        print("üé§ G1 TESTE MICROFONE REAL")
        print("=" * 50)
        
        if not self.initialize_sdk():
            return False
        
        if not self.setup_audio():
            return False
        
        # 1. Detectar microfones
        self.test_microphone_detection()
        
        # 2. Testar captura b√°sica
        captured_file = self.test_audio_capture()
        
        # 3. Testar G1 + captura simult√¢nea
        self.test_g1_audio_playback_with_capture()
        
        # 4. Testar direcionalidade
        self.test_microphone_directionality()
        
        print("\nüéâ TODOS OS TESTES CONCLU√çDOS!")
        
        # Resumo
        print(f"\nüìä RESUMO:")
        print("=" * 20)
        print("üé§ Microfone detectado: Sim")
        print("üìÅ Arquivos capturados:")
        print("  - captured_audio.wav")
        print("  - g1_audio_captured.wav")
        print("  - mic_test_frente.wav")
        print("  - mic_test_lado.wav")
        print("  - mic_test_atras.wav")
        print("üîç Verifique os arquivos para confirmar funcionamento")
        
        return True

def main():
    """Fun√ß√£o principal."""
    print("üé§ G1 TESTE MICROFONE REAL")
    print("=" * 60)
    print("üéØ OBJETIVO: Testar microfone real do G1")
    print("üìã TESTES:")
    print("  - Detec√ß√£o de microfones")
    print("  - Captura de √°udio")
    print("  - G1 + captura simult√¢nea")
    print("  - Teste de direcionalidade")
    
    response = input("\nDeseja continuar? (s/n): ").strip().lower()
    if response not in ['s', 'sim', 'y', 'yes']:
        print("‚ùå Opera√ß√£o cancelada")
        return
    
    tester = G1MicrophoneRealTest()
    
    if tester.run_test():
        print("\nüéâ TESTE CONCLU√çDO COM SUCESSO!")
    else:
        print("\n‚ùå TESTE FALHOU")

if __name__ == "__main__":
    main()
