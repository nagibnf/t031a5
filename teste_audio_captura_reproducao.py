#!/usr/bin/env python3
"""
üé§ TESTE SIMPLES - CAPTURA E REPRODU√á√ÉO DE √ÅUDIO
Testa se conseguimos capturar √°udio real do DJI Mic 2 e reproduzir
"""

import sys
import time
import asyncio
import logging
import tempfile
import subprocess
from pathlib import Path
import numpy as np
import wave

# Adiciona src ao path
sys.path.insert(0, str(Path(__file__).parent / "src"))
sys.path.insert(0, "/home/unitree/t031a5/src")

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class TesteAudioCapturareproducao:
    """Teste simples de captura e reprodu√ß√£o de √°udio."""
    
    def __init__(self):
        self.audio_manager = None
        self.arquivo_gravacao = None
    
    async def inicializar_audio(self):
        """Inicializa sistema de √°udio."""
        try:
            from t031a5.audio.hybrid_microphone_manager import HybridMicrophoneManager
            
            self.audio_manager = HybridMicrophoneManager({
                "sample_rate": 16000,
                "test_duration": 5,
                "auto_switch": True,
                "quality_threshold": 5  # Threshold mais baixo para teste
            })
            
            logger.info("‚úÖ Sistema de √°udio inicializado")
            
            # Mostrar status dos microfones
            results = self.audio_manager.run_full_diagnostics()
            current_mic = self.audio_manager.current_source.value if self.audio_manager.current_source else "none"
            
            logger.info(f"üé§ Microfone atual: {current_mic}")
            
            # Mostrar todos os microfones detectados
            for source, test in results["tests"].items():
                if "quality_score" in test:
                    score = test["quality_score"]
                    logger.info(f"   üìä {source}: {score}/100")
                else:
                    logger.info(f"   ‚ùå {source}: erro")
            
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao inicializar √°udio: {e}")
            return False
    
    def analisar_audio(self, audio_data: np.ndarray) -> dict:
        """Analisa qualidade do √°udio capturado."""
        if audio_data is None or len(audio_data) == 0:
            return {"valido": False, "motivo": "√Åudio vazio"}
        
        try:
            # Estat√≠sticas b√°sicas
            rms = np.sqrt(np.mean(audio_data**2))
            peak = np.max(np.abs(audio_data))
            duration = len(audio_data) / 16000  # Sample rate 16kHz
            
            # Verificar se parece √°udio real ou simulado
            # √Åudio simulado geralmente tem padr√µes muito regulares
            variance = np.var(audio_data)
            mean_abs = np.mean(np.abs(audio_data))
            
            # An√°lise de frequ√™ncia b√°sica
            zero_crossings = np.sum(np.diff(np.sign(audio_data)) != 0)
            zcr_rate = zero_crossings / len(audio_data)
            
            eh_simulado = (
                variance < 0.001 and  # Muito pouca varia√ß√£o
                mean_abs > 0.01 and   # Mas com amplitude constante
                zcr_rate < 0.01       # Muito poucas mudan√ßas de sinal
            )
            
            analise = {
                "valido": True,
                "samples": len(audio_data),
                "duracao": duration,
                "rms_level": rms,
                "peak_level": peak,
                "variance": variance,
                "zero_crossing_rate": zcr_rate,
                "provavelmente_simulado": eh_simulado,
                "qualidade": "REAL" if not eh_simulado else "SIMULADO"
            }
            
            return analise
            
        except Exception as e:
            return {"valido": False, "motivo": f"Erro na an√°lise: {e}"}
    
    async def capturar_audio(self, duracao: float = 5.0):
        """Captura √°udio por dura√ß√£o especificada."""
        if not self.audio_manager:
            logger.error("‚ùå Sistema de √°udio n√£o inicializado")
            return None
        
        try:
            logger.info(f"üé§ INICIANDO CAPTURA DE √ÅUDIO ({duracao}s)...")
            logger.info("üó£Ô∏è FALE ALGO NO MICROFONE AGORA!")
            
            # Contador regressivo
            for i in range(3, 0, -1):
                logger.info(f"‚è∞ {i}...")
                await asyncio.sleep(1)
            
            logger.info("üî¥ GRAVANDO...")
            
            # Capturar √°udio
            audio_data, source = self.audio_manager.capture_audio(duration=duracao)
            
            if audio_data is not None:
                logger.info(f"‚úÖ Captura conclu√≠da via {source.value}")
                return audio_data, source.value
            else:
                logger.error("‚ùå Falha na captura")
                return None, "erro"
                
        except Exception as e:
            logger.error(f"‚ùå Erro na captura: {e}")
            return None, "exce√ß√£o"
    
    def salvar_audio(self, audio_data: np.ndarray, filename: str = None) -> str:
        """Salva √°udio em arquivo WAV."""
        try:
            if filename is None:
                timestamp = int(time.time())
                filename = f"captura_audio_{timestamp}.wav"
            
            # Converter para int16
            if audio_data.dtype != np.int16:
                # Normalizar para range int16
                audio_data = audio_data / np.max(np.abs(audio_data))
                audio_data = (audio_data * 32767).astype(np.int16)
            
            # Salvar WAV
            with wave.open(filename, 'wb') as wav_file:
                wav_file.setnchannels(1)  # Mono
                wav_file.setsampwidth(2)  # 16-bit
                wav_file.setframerate(16000)  # 16kHz
                wav_file.writeframes(audio_data.tobytes())
            
            file_size = Path(filename).stat().st_size
            logger.info(f"üíæ √Åudio salvo: {filename} ({file_size} bytes)")
            self.arquivo_gravacao = filename
            return filename
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao salvar: {e}")
            return None
    
    async def reproduzir_audio(self, filename: str) -> bool:
        """Reproduz √°udio salvo."""
        if not filename or not Path(filename).exists():
            logger.error("‚ùå Arquivo n√£o encontrado")
            return False
        
        try:
            logger.info(f"üîä REPRODUZINDO: {filename}")
            
            # Tentar diferentes m√©todos de reprodu√ß√£o
            m√©todos = [
                ["paplay", filename],  # PulseAudio (padr√£o Linux)
                ["aplay", filename],   # ALSA direto
                ["play", filename],    # SoX
            ]
            
            for m√©todo in m√©todos:
                try:
                    result = subprocess.run(
                        m√©todo, 
                        check=True, 
                        timeout=15,
                        capture_output=True
                    )
                    logger.info(f"‚úÖ Reprodu√ß√£o OK via {m√©todo[0]}")
                    return True
                except subprocess.CalledProcessError as e:
                    logger.warning(f"‚ö†Ô∏è {m√©todo[0]} falhou: {e}")
                except FileNotFoundError:
                    logger.warning(f"‚ö†Ô∏è {m√©todo[0]} n√£o encontrado")
                except subprocess.TimeoutExpired:
                    logger.warning(f"‚ö†Ô∏è {m√©todo[0]} timeout")
            
            logger.error("‚ùå Nenhum m√©todo de reprodu√ß√£o funcionou")
            return False
            
        except Exception as e:
            logger.error(f"‚ùå Erro na reprodu√ß√£o: {e}")
            return False
    
    def verificar_dispositivos_audio(self):
        """Verifica dispositivos de √°udio dispon√≠veis."""
        logger.info("üîç VERIFICANDO DISPOSITIVOS DE √ÅUDIO...")
        
        try:
            # PulseAudio - Sources (entrada)
            result = subprocess.run(
                ["pactl", "list", "sources", "short"], 
                capture_output=True, text=True, timeout=10
            )
            
            if result.returncode == 0:
                logger.info("üì• DISPOSITIVOS DE ENTRADA:")
                lines = result.stdout.strip().split('\n')
                for line in lines:
                    if line.strip():
                        parts = line.split('\t')
                        if len(parts) >= 2:
                            device_id = parts[0]
                            device_name = parts[1]
                            if 'dji' in device_name.lower() or 'mic' in device_name.lower():
                                logger.info(f"   üé§ {device_id}: {device_name}")
                            else:
                                logger.info(f"   üì± {device_id}: {device_name}")
            
            # PulseAudio - Sinks (sa√≠da)
            result = subprocess.run(
                ["pactl", "list", "sinks", "short"], 
                capture_output=True, text=True, timeout=10
            )
            
            if result.returncode == 0:
                logger.info("üì§ DISPOSITIVOS DE SA√çDA:")
                lines = result.stdout.strip().split('\n')
                for line in lines:
                    if line.strip():
                        parts = line.split('\t')
                        if len(parts) >= 2:
                            device_id = parts[0]
                            device_name = parts[1]
                            if 'anker' in device_name.lower() or 'bluetooth' in device_name.lower():
                                logger.info(f"   üîä {device_id}: {device_name}")
                            else:
                                logger.info(f"   üéß {device_id}: {device_name}")
                                
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Erro ao verificar dispositivos: {e}")
    
    async def executar_teste_completo(self):
        """Executa teste completo de captura e reprodu√ß√£o."""
        logger.info("üé§üîä TESTE CAPTURA E REPRODU√á√ÉO DE √ÅUDIO")
        logger.info("="*60)
        
        # 1. Verificar dispositivos
        self.verificar_dispositivos_audio()
        logger.info("="*60)
        
        # 2. Inicializar sistema
        if not await self.inicializar_audio():
            logger.error("‚ùå Falha na inicializa√ß√£o")
            return
        
        logger.info("="*60)
        
        # 3. Capturar √°udio
        audio_data, source = await self.capturar_audio(5.0)
        
        if audio_data is None:
            logger.error("‚ùå Falha na captura - teste encerrado")
            return
        
        # 4. Analisar √°udio
        logger.info("üîç ANALISANDO √ÅUDIO CAPTURADO...")
        analise = self.analisar_audio(audio_data)
        
        if not analise["valido"]:
            logger.error(f"‚ùå √Åudio inv√°lido: {analise['motivo']}")
            return
        
        # Mostrar an√°lise
        logger.info(f"üìä AN√ÅLISE DO √ÅUDIO:")
        logger.info(f"   üìè Samples: {analise['samples']:,}")
        logger.info(f"   ‚è±Ô∏è Dura√ß√£o: {analise['duracao']:.2f}s")
        logger.info(f"   üìà RMS Level: {analise['rms_level']:.4f}")
        logger.info(f"   üìä Peak Level: {analise['peak_level']:.4f}")
        logger.info(f"   üîÄ Zero Crossing Rate: {analise['zero_crossing_rate']:.4f}")
        logger.info(f"   üéØ Qualidade: {analise['qualidade']}")
        
        if analise["provavelmente_simulado"]:
            logger.warning("‚ö†Ô∏è ATEN√á√ÉO: √Åudio parece ser SIMULADO!")
        else:
            logger.info("‚úÖ √Åudio parece ser REAL!")
        
        logger.info("="*60)
        
        # 5. Salvar arquivo
        logger.info("üíæ SALVANDO √ÅUDIO...")
        filename = self.salvar_audio(audio_data)
        
        if not filename:
            logger.error("‚ùå Falha ao salvar")
            return
        
        # 6. Aguardar um pouco
        logger.info("‚è≥ Aguardando 2s antes da reprodu√ß√£o...")
        await asyncio.sleep(2)
        
        # 7. Reproduzir
        logger.info("üîä REPRODUZINDO √ÅUDIO CAPTURADO...")
        sucesso_reproducao = await self.reproduzir_audio(filename)
        
        # 8. Resultado final
        logger.info("="*60)
        logger.info("üìã RESULTADO DO TESTE:")
        logger.info(f"   üé§ Captura: ‚úÖ OK via {source}")
        logger.info(f"   üíæ Arquivo: ‚úÖ {filename}")
        logger.info(f"   üîä Reprodu√ß√£o: {'‚úÖ OK' if sucesso_reproducao else '‚ùå FALHA'}")
        logger.info(f"   üéØ Qualidade: {analise['qualidade']}")
        
        if analise["qualidade"] == "REAL" and sucesso_reproducao:
            logger.info("üéâ TESTE COMPLETO: SUCESSO TOTAL!")
        elif analise["qualidade"] == "REAL":
            logger.info("‚ö†Ô∏è TESTE PARCIAL: Captura OK, reprodu√ß√£o com problemas")
        else:
            logger.info("‚ö†Ô∏è TESTE LIMITADO: Usando √°udio simulado")
        
        logger.info("="*60)
        
        # Limpeza opcional
        try:
            if filename and Path(filename).exists():
                keep = input("\nüíæ Manter arquivo gravado? (s/n): ").lower().strip()
                if keep not in ['s', 'sim', 'y', 'yes']:
                    Path(filename).unlink()
                    logger.info(f"üóëÔ∏è Arquivo {filename} removido")
                else:
                    logger.info(f"üíæ Arquivo mantido: {filename}")
        except:
            pass  # N√£o √© cr√≠tico

async def main():
    """Fun√ß√£o principal."""
    teste = TesteAudioCapturareproducao()
    await teste.executar_teste_completo()

if __name__ == "__main__":
    asyncio.run(main())
